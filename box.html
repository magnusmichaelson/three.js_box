<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body>
 <canvas id="my_canvas" width="800" height="400"></canvas>
<script src="./dependencies/three.min.js"></script>
<script src="./dependencies/PointerLockControls.js"></script>
<script>
var camera;
var controls;
var controlsEnabled = false;
var moveForward = false;
var moveBackward = false;
var moveLeft = false;
var moveRight = false;
var moveUp = false;
var moveDown = false;
var objectInLineOfSightCurrent;
var objectInLineOfSightPrevious;
var prevTime;
var renderer;
var scene;
var serverLink;
var speed = 6;
var speedBoost = false;
var velocity;
rendererResize();
window.addEventListener("resize", rendererResize, false);
start();

function mouseClick(event) {
    if (event.button == 0) {
        mouseLeftClick();
    }
    if (event.button == 1) {
        mouseMiddleClick();
    }
    if (event.button == 2) {
        mouseRightClick();
    }
}
function mouseLeftClick() {
    console.log(objectInLineOfSightCurrent);
}
function mouseMiddleClick() {
    console.log(objectInLineOfSightCurrent);
}
function mouseRightClick() {
    console.log(objectInLineOfSightCurrent);
}

function animate() {
    var closestDistance;
    var colorBlue;
    var colorGreen;
    var colorRed;
    var lineOfSightResult;
    requestAnimationFrame(animate);
    lineOfSightResult = animationFindLineOfSight();
    closestDistance = lineOfSightResult["closestDistance"];
    objectInLineOfSightCurrent = lineOfSightResult["closest"];
    if (closestDistance != -1) {
        if (objectInLineOfSightCurrent != objectInLineOfSightPrevious) {
            if (objectInLineOfSightCurrent.userData.highlightable) {
                colorBlue = objectInLineOfSightCurrent.userData.highlightBlue;
                colorGreen = objectInLineOfSightCurrent.userData.highlightGreen;
                colorRed = objectInLineOfSightCurrent.userData.highlightRed;
                objectInLineOfSightCurrent.material.color.setRGB(colorRed, colorGreen, colorBlue);
            }
        }
    }
    if (objectInLineOfSightCurrent != objectInLineOfSightPrevious) {
        if (objectInLineOfSightPrevious) {
            if (objectInLineOfSightPrevious.userData.highlightable) {
                colorBlue = objectInLineOfSightPrevious.userData.colorBlue;
                colorGreen = objectInLineOfSightPrevious.userData.colorGreen;
                colorRed = objectInLineOfSightPrevious.userData.colorRed;
                objectInLineOfSightPrevious.material.color.setRGB(colorRed, colorGreen, colorBlue);
            }
        }
        objectInLineOfSightPrevious = objectInLineOfSightCurrent;
    }
    if (controlsEnabled) {
        var time = performance.now();
        var delta = (time - prevTime);
        if (speedBoost) {
            delta = delta * 5 / 1000;
        }
        else {
            delta = delta / 1000;
        }
        velocity.x = 0;
        velocity.z = 0;
        if (moveForward)
            velocity.z = -speed * delta;
        if (moveBackward)
            velocity.z = speed * delta;
        if (moveLeft)
            velocity.x = -speed * delta;
        if (moveRight)
            velocity.x = speed * delta;
        controls.getObject().translateX(velocity.x);
        controls.getObject().translateZ(velocity.z);
        if (moveDown) {
            controls.getObject().position.y -= (speed * delta);
        }
        if (moveUp) {
            controls.getObject().position.y += (speed * delta);
        }
        prevTime = time;
    }
    renderer.render(scene, camera);
}
function animationFindLineOfSight() {
    var cameraDirection;
    var cameraPostion;
    var closest;
    var closestDistance;
    var intersects;
    var raycaster = new THREE.Raycaster();
    cameraPostion = new THREE.Vector3();
    cameraDirection = new THREE.Vector3();
    closestDistance = -1;
    camera.getWorldPosition(cameraPostion);
    camera.getWorldDirection(cameraDirection);
    raycaster.set(cameraPostion, cameraDirection);
    var intersects = raycaster.intersectObjects(scene.children);
    if (intersects.length > 0) {
        for (var i = 0; i < intersects.length; i++) {
            if (closestDistance == -1) {
                closestDistance = intersects[i].distance;
                closest = intersects[i].object;
            }
            else {
                if (intersects[i].distance < closestDistance) {
                    closestDistance = intersects[i].distance;
                    closest = intersects[i].object;
                }
            }
        }
    }
    return ({
        closest: closest,
        closestDistance: closestDistance
    });
}
function start() {
    var havePointerLock;
    havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
    if (havePointerLock) {
        document.addEventListener('pointerlockchange', pointerlockchange, false);
        document.addEventListener('mozpointerlockchange', pointerlockchange, false);
        document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
        generateScene();
        //changeColor();
        animate();
    }
    else {
        console.log('Your browser doesn\'t seem to support Pointer Lock API');
    }
}
/**
 * @function generateScene
 * @description generate everything in the 3D scene
 */
function generateScene() {
    addEventListeners();
    addThreeJsContent();
    buildRacks();
    rendererResize();
}
function buildRacks() {
    var blockName;
    var blockSysid;
    var color;
    var countRow;
    var countRack;
    var highlightable;
    var lineColor;
    var type;
    var xCenter;
    var xSize;
    var yCenter;
    var ySize;
    var zCenter;
    var zSize;
    for (countRow = 0; countRow < 10; countRow++){
        for (countRack = 0; countRack < 10; countRack++){
            blockName = "rack_" + countRow + "+" + countRack;
            blockSysid = "";
            color = { "red": 1.0, "green": 1.0, "blue": 1.0 };;
            highlightable = false;
            lineColor = { "red": 0.3, "green": 0.3, "blue": 0.3 };
            xCenter = (countRow * 2) + 2;  
            xSize = 1;
            yCenter = countRack + 2;
            ySize = 1;
            zCenter = 1.5;
            zSize = 3
            type = "rack";
            addCuboid(blockName, blockSysid, color, highlightable, type, lineColor, xCenter, xSize, yCenter, ySize, zCenter, zSize);
        }
    }
}
function addPlane(objectData, plane) {
    var geometry;
    var material;
    var mesh;
    geometry = new THREE.PlaneGeometry(plane["planeWidth"], plane["planeHeight"]);
    material = new THREE.MeshStandardMaterial({ side: THREE.DoubleSide });
    material.color.setRGB(objectData["colorRed"], objectData["colorGreen"], objectData["colorBlue"]);
    mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = plane["yCenter"];
    mesh.position.y = plane["zCenter"];
    mesh.position.z = plane["xCenter"];
    mesh.rotation.y = plane["planeZRotation"];
    mesh.name = objectData["name"];
    mesh.userData.ciSysId = objectData["ciSysId"];
    mesh.userData.colorRed = objectData["colorRed"];
    mesh.userData.colorGreen = objectData["colorGreen"];
    mesh.userData.colorBlue = objectData["colorBlue"];
    mesh.userData.hardwareSysId = objectData["hardwareSysId"];
    mesh.userData.highlightable = objectData["highlightable"];
    mesh.userData.highlightRed = objectData["highlightRed"];
    mesh.userData.highlightGreen = objectData["highlightGreen"];
    mesh.userData.highlightBlue = objectData["highlightBlue"];
    mesh.userData.type = objectData["type"];
    scene.add(mesh);
}
function addCuboid(blockName, blockSysid, color, highlightable, type, lineColor, xCenter, xSize, yCenter, ySize, zCenter, zSize) {
    var edges;
    var geometry;
    var line;
    var material;
    var mesh;
    geometry = new THREE.BoxGeometry(ySize, zSize, xSize);
    material = new THREE.MeshStandardMaterial();
    material.color.setRGB(color["red"], color["green"], color["blue"]);
    mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = yCenter;
    mesh.position.y = zCenter;
    mesh.position.z = xCenter;
    mesh.name = blockName;
    mesh.userData.highlightable = highlightable;
    mesh.userData.sysid = blockSysid;
    mesh.userData.type = type;
    scene.add(mesh);
    edges = new THREE.EdgesGeometry(geometry);
    material = new THREE.LineBasicMaterial();
    material.color.setRGB(lineColor["red"], lineColor["green"], lineColor["blue"]);
    line = new THREE.LineSegments(edges, material);
    mesh.add(line);
}
function addThreeJsContent() {
    var cameraPositionX = -4.0;
    var cameraPositionY = 1.9;
    var cameraPositionZ = -4.0;
    var cameraRotationX = 3.141;
    var cameraRotationY = -0.785;
    var cameraRotationZ = 3.141;
    var crosshair;
    var geometry;
    var light;
    var material;
    velocity = new THREE.Vector3();
    scene = new THREE.Scene();
    light = new THREE.AmbientLight(0xffffff);
    scene.add(light);
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 1000);
    controls = new THREE.PointerLockControls(camera, document.body);
    controls.getObject().position.set(cameraPositionX, cameraPositionY, cameraPositionZ);
    controls.getObject().rotation.set(cameraRotationX, cameraRotationY, cameraRotationZ);
    scene.add(camera);
    geometry = new THREE.Geometry();
    geometry.vertices.push(new THREE.Vector3(0, 0.001, -0.1));
    geometry.vertices.push(new THREE.Vector3(0, -0.001, -0.1));
    geometry.vertices.push(new THREE.Vector3(0.001, 0, -0.1));
    geometry.vertices.push(new THREE.Vector3(-0.001, 0, -0.1));
    material = new THREE.LineBasicMaterial({ color: 0x000000 });
    crosshair = new THREE.LineSegments(geometry, material);
    camera.add(crosshair);
    renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('my_canvas') });
    renderer.setClearColor(0xf0f3f4);
}
function addEventListeners() {
    document.getElementById('my_canvas').addEventListener('click', pointerLockRequest, false);
    document.addEventListener('keydown', onKeyDown, false);
    document.addEventListener('keyup', onKeyUp, false);
}
function pointerLockRequest() {
    var element = document.body;
    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
    element.requestPointerLock();
}
function pointerlockchange() {
    var element = document.body;
    if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
        controlsEnabled = true;
        moveForward = false;
        moveBackward = false;
        moveLeft = false;
        moveRight = false;
        moveUp = false;
        moveDown = false;
        prevTime = performance.now();
        document.addEventListener('click', mouseClick, false);
    }
    else {
        document.removeEventListener('click', mouseClick, false);
        controlsEnabled = false;
    }
}
function onKeyDown(event) {
    switch (event.keyCode) {
        case 38: // up
        case 87: // w
            moveForward = true;
            break;
        case 37: // left
        case 65: // a
            moveLeft = true;
            break;
        case 40: // down
        case 83: // s
            moveBackward = true;
            break;
        case 39: // right
        case 68: // d
            moveRight = true;
            break;
        case 16: // left shift
            moveDown = true;
            break;
        case 32: // space
            moveUp = true;
            break;
        case 69: // e
            speedBoost = true;
            break;
    }
}
function onKeyUp(event) {
    switch (event.keyCode) {
        case 38: // up
        case 87: // w
            moveForward = false;
            break;
        case 37: // left
        case 65: // a
            moveLeft = false;
            break;
        case 40: // down
        case 83: // s
            moveBackward = false;
            break;
        case 39: // right
        case 68: // d
            moveRight = false;
            break;
        case 16: // left shift
            moveDown = false;
            break;
        case 32: // space
            moveUp = false;
            break;
        case 69: // e
            speedBoost = false;
            break;
    }
}
function rendererResize() {
    var canvasHeight;
    var canvasWidth;
    var centerHeight;
    var divElement;
    var left;
    var lowerHeight;
    var pagewidth;
    var pageheight;
    canvasWidth = window.innerWidth - 16;
    canvasHeight = window.innerHeight - 16;
    divElement = document.getElementById("my_canvas");
    divElement.style.position = 'absolute';
    divElement.style.left = "0px";
    divElement.style.top = "0px";
    divElement.style.width = canvasWidth + "px";
    divElement.style.height = canvasHeight + "px";
    if (camera) {
        camera.aspect = canvasWidth / canvasHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(canvasWidth, canvasHeight);
    }
}
</script>
</body>
</html>
