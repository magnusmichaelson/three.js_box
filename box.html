<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body>
 <canvas id="my_canvas" width="800" height="400"></canvas>
<script src="./dependencies/three.min.js"></script>
<script src="./dependencies/PointerLockControls.js"></script>
<script src="./testData.js"></script>
<script>

//function main(spUtil){
// global variables
var camera;
var controls;
var controlsEnabled = false;
var moveForward = false;
var moveBackward = false;
var moveLeft = false;
var moveRight = false;
var moveUp = false;
var moveDown = false;
var objectInLineOfSightCurrent;
var objectInLineOfSightPrevious;
var prevTime;
var renderer;
var scene;
var serverLink;
var speed = 6;
var speedBoost = false;
var velocity;
// data from server
var ciColor = {};
var ciComment = {};
var emptyBasic = {};
var emptyToRack = {};
var hardwareBasic = {};
var hardwareError = {};
var powerIqFinalData = {};
var rackBasic = {};
var rackCartesian = {};
var rackColor = {};
var rackComment = {};
var rackDesign = {};
var rackEmpty = {};
var rackHardware = {};
var rackSysIdValid = {};
var roomName;
var roomPowerMaximum;
var roomSysid;
// colors
var defaultColorEmpty = { "red": 0.0, "green": 0.0, "blue": 0.0 };
var defaultColorUnselectedRack = { "red": 0.4, "green": 0.4, "blue": 0.4 };
var defaultColorHardRed = { "red": 1.0, "green": 0.0, "blue": 0.0 };
var defaultColorHardware = { "red": 0.8, "green": 0.8, "blue": 0.8 };
var defaultColorRack = { "red": 1.0, "green": 1.0, "blue": 1.0 };
rendererResize();
// @ts-ignore
window.addEventListener("resize", rendererResize, false);
var allData = fakeData();
ciColor = allData["ciColor"];
ciComment = allData["ciComment"];
emptyBasic = allData["emptyBasic"];
emptyToRack = allData["emptyToRack"];
hardwareBasic = allData["hardwareBasic"];
hardwareError = allData["hardwareError"];
rackBasic = allData["rackBasic"];
rackCartesian = allData["rackCartesian"];
rackColor = allData["rackColor"];
rackComment = allData["rackComment"];
rackDesign = allData["rackDesign"];
rackEmpty = allData["rackEmpty"];
rackHardware = allData["rackHardware"];
rackSysIdValid = allData["rackSysIdValid"];
roomName = allData["roomName"];
roomSysid = allData["roomSysid"];
checkForPointerLock();
///////////
// menus //
///////////
function mouseClick(event) {
    if (event.button == 0) {
        mouseLeftClick();
    }
    if (event.button == 1) {
        mouseMiddleClick();
    }
    if (event.button == 2) {
        mouseRightClick();
    }
}
function mouseLeftClick() {
    console.log(objectInLineOfSightCurrent);
}
function mouseMiddleClick() {
    console.log(objectInLineOfSightCurrent);
}
function mouseRightClick() {
    console.log(objectInLineOfSightCurrent);
}
///////////////////////////
// visualization control //
///////////////////////////
/////////////////////////////////////
// recoloring objects in the scene //
/////////////////////////////////////
function changeColor() {
    var rackChosen;
    Object.keys(rackSysIdValid).forEach(function (rackSysid) {
        rackChosen = checkrackChosen(rackSysid);
        colorRack(rackSysid, rackChosen);
        rackHardware[rackSysid].forEach(function (hardwareSysid) {
            colorHardware(rackChosen, hardwareSysid);
        });
        rackEmpty[rackSysid].forEach(function (emptyId) {
            colorEmpty(rackChosen, emptyId);
        });
    });
}
function checkrackChosen(rackSysid) {
    var rackChosen;
    rackChosen = true;
}
function colorRack(rackSysid, rackChosen) {
    var color;
    var rackToColor;
    color = { "red": 0.0, "green": 0.0, "blue": 0.0 };
    color["red"] = defaultColorUnselectedRack["red"];
    color["green"] = defaultColorUnselectedRack["green"];
    color["blue"] = defaultColorUnselectedRack["blue"];
    if (rackChosen) {
        color["red"] = rackColor[rackSysid]["red"];
        color["green"] = rackColor[rackSysid]["green"];
        color["blue"] = rackColor[rackSysid]["blue"];
    }
    rackToColor = scene.getObjectByName("rack_" + rackSysid);
    if (rackToColor) {
        rackToColor.material.color.setRGB(color["red"], color["green"], color["blue"]);
    }
}
function colorHardware(rackChosen, hardwareSysid) {
    var ciSysId;
    var color;
    var hardwareFilterValue;
    var hardwareOverlayValue;
    var hardwareToColor;
    var highlightable;
    var highlightColor;
    highlightable = false;
    hardwareToColor = scene.getObjectByName("hardware_" + hardwareSysid);
    if (hardwareToColor) {
        // @ts-ignore
        //hardwareOverlayValue = document.getElementById('hardwareOverlay').value;
        // @ts-ignore
        //hardwareFilterValue = document.getElementById('hardwareFilter').value;
        // @ts-ignore
        hardwareOverlayValue = "default";
        // @ts-ignore
        hardwareFilterValue = "all";
        highlightable = false;
        color = { "red": 0.0, "green": 0.0, "blue": 0.0 };
        highlightColor = { "red": 0.0, "green": 0.0, "blue": 0.0 };
        color["red"] = defaultColorUnselectedRack["red"];
        color["green"] = defaultColorUnselectedRack["green"];
        color["blue"] = defaultColorUnselectedRack["blue"];
        highlightColor["red"] = defaultColorUnselectedRack["red"];
        highlightColor["green"] = defaultColorUnselectedRack["green"];
        highlightColor["blue"] = defaultColorUnselectedRack["blue"];
        if (rackChosen) {
            if (hardwareFilterValue == 'all' || hardwareFilterValue == hardwareBasic[hardwareSysid]["supportgroup_name"]) {
                color["red"] = defaultColorHardware["red"];
                color["green"] = defaultColorHardware["green"];
                color["blue"] = defaultColorHardware["blue"];
                highlightColor["red"] = defaultColorHardware["red"];
                highlightColor["green"] = defaultColorHardware["green"];
                highlightColor["blue"] = defaultColorHardware["blue"];
                if (hardwareError[hardwareSysid]) {
                    if (hardwareOverlayValue == 'default') {
                        color["red"] = defaultColorHardRed["red"];
                        color["green"] = defaultColorHardRed["green"];
                        color["blue"] = defaultColorHardRed["blue"];
                        highlightColor["red"] = defaultColorHardRed["red"];
                        highlightColor["green"] = defaultColorHardRed["green"];
                        highlightColor["blue"] = defaultColorHardRed["blue"];
                    }
                    else {
                        color["red"] = defaultColorUnselectedRack["red"];
                        color["green"] = defaultColorUnselectedRack["green"];
                        color["blue"] = defaultColorUnselectedRack["blue"];
                        highlightColor["red"] = defaultColorUnselectedRack["red"];
                        highlightColor["green"] = defaultColorUnselectedRack["green"];
                        highlightColor["blue"] = defaultColorUnselectedRack["blue"];
                    }
                }
                ciSysId = hardwareToColor.userData.ciSysId;
                if (ciSysId) {
                    if (ciColor.hasOwnProperty(ciSysId)) {
                        color["red"] = ciColor[ciSysId]["red"];
                        color["green"] = ciColor[ciSysId]["green"];
                        color["blue"] = ciColor[ciSysId]["blue"];
                        highlightColor["red"] = ciColor[ciSysId]["red"] * 0.6;
                        highlightColor["green"] = ciColor[ciSysId]["green"] * 0.6;
                        highlightColor["blue"] = ciColor[ciSysId]["blue"] * 0.6;
                        highlightable = true;
                    }
                }
            }
        }
        else {
            color["red"] = defaultColorUnselectedRack["red"];
            color["green"] = defaultColorUnselectedRack["green"];
            color["blue"] = defaultColorUnselectedRack["blue"];
            highlightColor["red"] = defaultColorUnselectedRack["red"];
            highlightColor["green"] = defaultColorUnselectedRack["green"];
            highlightColor["blue"] = defaultColorUnselectedRack["blue"];
        }
        hardwareToColor.material.color.setRGB(color["red"], color["green"], color["blue"]);
        hardwareToColor.userData.colorRed = color["red"];
        hardwareToColor.userData.colorGreen = color["green"];
        hardwareToColor.userData.colorBlue = color["blue"];
        hardwareToColor.userData.highlightable = highlightable;
        hardwareToColor.userData.highlightRed = highlightColor["red"];
        hardwareToColor.userData.highlightGreen = highlightColor["green"];
        hardwareToColor.userData.highlightBlue = highlightColor["blue"];
    }
}
function colorEmpty(rackChosen, emptyId) {
    var color;
    var emptyToColor;
    color = { "red": 0.0, "green": 0.0, "blue": 0.0 };
    color["red"] = defaultColorUnselectedRack["red"];
    color["green"] = defaultColorUnselectedRack["green"];
    color["blue"] = defaultColorUnselectedRack["blue"];
    if (rackChosen) {
        color["red"] = defaultColorEmpty["red"];
        color["green"] = defaultColorEmpty["green"];
        color["blue"] = defaultColorEmpty["blue"];
    }
    emptyToColor = scene.getObjectByName(emptyId);
    if (emptyToColor) {
        emptyToColor.material.color.setRGB(color["red"], color["green"], color["blue"]);
    }
}
///////////////
// animation //
///////////////
/**
 * @function animate
 * @description the animation loop
 */
function animate() {
    var closestDistance;
    var colorBlue;
    var colorGreen;
    var colorRed;
    var lineOfSightResult;
    requestAnimationFrame(animate);
    lineOfSightResult = animationFindLineOfSight();
    closestDistance = lineOfSightResult["closestDistance"];
    objectInLineOfSightCurrent = lineOfSightResult["closest"];
    if (closestDistance != -1) {
        if (objectInLineOfSightCurrent != objectInLineOfSightPrevious) {
            if (objectInLineOfSightCurrent.userData.highlightable) {
                colorBlue = objectInLineOfSightCurrent.userData.highlightBlue;
                colorGreen = objectInLineOfSightCurrent.userData.highlightGreen;
                colorRed = objectInLineOfSightCurrent.userData.highlightRed;
                objectInLineOfSightCurrent.material.color.setRGB(colorRed, colorGreen, colorBlue);
            }
        }
    }
    if (objectInLineOfSightCurrent != objectInLineOfSightPrevious) {
        if (objectInLineOfSightPrevious) {
            if (objectInLineOfSightPrevious.userData.highlightable) {
                colorBlue = objectInLineOfSightPrevious.userData.colorBlue;
                colorGreen = objectInLineOfSightPrevious.userData.colorGreen;
                colorRed = objectInLineOfSightPrevious.userData.colorRed;
                objectInLineOfSightPrevious.material.color.setRGB(colorRed, colorGreen, colorBlue);
            }
        }
        objectInLineOfSightPrevious = objectInLineOfSightCurrent;
    }
    if (controlsEnabled) {
        var time = performance.now();
        var delta = (time - prevTime);
        // @ts-ignore
        //document.getElementById("fps").innerText = "FPS: " + Math.floor(1000 / delta);
        if (speedBoost) {
            delta = delta * 5 / 1000;
        }
        else {
            delta = delta / 1000;
        }
        velocity.x = 0;
        velocity.z = 0;
        if (moveForward)
            velocity.z = -speed * delta;
        if (moveBackward)
            velocity.z = speed * delta;
        if (moveLeft)
            velocity.x = -speed * delta;
        if (moveRight)
            velocity.x = speed * delta;
        controls.getObject().translateX(velocity.x);
        controls.getObject().translateZ(velocity.z);
        if (moveDown) {
            controls.getObject().position.y -= (speed * delta);
        }
        if (moveUp) {
            controls.getObject().position.y += (speed * delta);
        }
        prevTime = time;
    }
    renderer.render(scene, camera);
}
function animationFindLineOfSight() {
    var cameraDirection;
    var cameraPostion;
    var closest;
    var closestDistance;
    var intersects;
    // @ts-ignore
    var raycaster = new THREE.Raycaster();
    // @ts-ignore
    cameraPostion = new THREE.Vector3();
    // @ts-ignore
    cameraDirection = new THREE.Vector3();
    closestDistance = -1;
    camera.getWorldPosition(cameraPostion);
    camera.getWorldDirection(cameraDirection);
    raycaster.set(cameraPostion, cameraDirection);
    var intersects = raycaster.intersectObjects(scene.children);
    if (intersects.length > 0) {
        for (var i = 0; i < intersects.length; i++) {
            if (closestDistance == -1) {
                closestDistance = intersects[i].distance;
                closest = intersects[i].object;
            }
            else {
                if (intersects[i].distance < closestDistance) {
                    closestDistance = intersects[i].distance;
                    closest = intersects[i].object;
                }
            }
        }
    }
    return ({
        closest: closest,
        closestDistance: closestDistance
    });
}
function checkForPointerLock() {
    var havePointerLock;
    havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
    if (havePointerLock) {
        document.addEventListener('pointerlockchange', pointerlockchange, false);
        document.addEventListener('mozpointerlockchange', pointerlockchange, false);
        document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
        generateScene();
        changeColor();
        animate();
    }
    else {
        console.log('Your browser doesn\'t seem to support Pointer Lock API');
    }
}
/**
 * @function generateScene
 * @description generate everything in the 3D scene
 */
function generateScene() {
    addEventListeners();
    addThreeJsContent();
    buildRacks();
    rendererResize();
}
function buildRacks() {
    Object.keys(rackSysIdValid).forEach(function (rackSysid) {
        if (rackCartesian.hasOwnProperty(rackSysid)) {
            addCartesianRack(rackSysid);
        }
    });
}
function addCartesianRack(rackSysid) {
    var blockName;
    var blockSysid;
    var color;
    var highlightable;
    var lineColor;
    var type;
    var xCenter;
    var xSize;
    var yCenter;
    var ySize;
    var zCenter;
    var zSize;
    blockName = "rack_" + rackSysid;
    blockSysid = rackSysid;
    color = defaultColorRack;
    highlightable = false;
    lineColor = { "red": 0.3, "green": 0.3, "blue": 0.3 };
    xCenter = rackCartesian[rackSysid]["u_x_center"];
    xSize = rackCartesian[rackSysid]["u_x_size"];
    yCenter = rackCartesian[rackSysid]["u_y_center"];
    ySize = rackCartesian[rackSysid]["u_y_size"];
    zCenter = rackCartesian[rackSysid]["u_z_center"];
    zSize = rackCartesian[rackSysid]["u_z_size"];
    type = "rack";
    addCuboid(blockName, blockSysid, color, highlightable, type, lineColor, xCenter, xSize, yCenter, ySize, zCenter, zSize);
    //addRackObjects(rackSysid);
    //addRackEmptySlots(rackSysid, rackEmpty, emptyBasic);
}
function addPlane(objectData, plane) {
    var geometry;
    var material;
    var mesh;
    // @ts-ignore
    geometry = new THREE.PlaneGeometry(plane["planeWidth"], plane["planeHeight"]);
    // @ts-ignore
    material = new THREE.MeshStandardMaterial({ side: THREE.DoubleSide });
    // @ts-ignore
    material.color.setRGB(objectData["colorRed"], objectData["colorGreen"], objectData["colorBlue"]);
    // @ts-ignore
    mesh = new THREE.Mesh(geometry, material);
    // @ts-ignore
    mesh.position.x = plane["yCenter"];
    // @ts-ignore
    mesh.position.y = plane["zCenter"];
    // @ts-ignore
    mesh.position.z = plane["xCenter"];
    // @ts-ignore
    mesh.rotation.y = plane["planeZRotation"];
    // @ts-ignore
    mesh.name = objectData["name"];
    // @ts-ignore
    mesh.userData.ciSysId = objectData["ciSysId"];
    mesh.userData.colorRed = objectData["colorRed"];
    mesh.userData.colorGreen = objectData["colorGreen"];
    mesh.userData.colorBlue = objectData["colorBlue"];
    mesh.userData.hardwareSysId = objectData["hardwareSysId"];
    mesh.userData.highlightable = objectData["highlightable"];
    mesh.userData.highlightRed = objectData["highlightRed"];
    mesh.userData.highlightGreen = objectData["highlightGreen"];
    mesh.userData.highlightBlue = objectData["highlightBlue"];
    mesh.userData.type = objectData["type"];
    // @ts-ignore
    scene.add(mesh);
}
function addCuboid(blockName, blockSysid, color, highlightable, type, lineColor, xCenter, xSize, yCenter, ySize, zCenter, zSize) {
    var edges;
    var geometry;
    var line;
    var material;
    var mesh;
    // @ts-ignore
    //geometry = new THREE.BoxGeometry(xSize,ySize,zSize);
    geometry = new THREE.BoxGeometry(ySize, zSize, xSize);
    // @ts-ignore
    material = new THREE.MeshStandardMaterial();
    // @ts-ignore
    material.color.setRGB(color["red"], color["green"], color["blue"]);
    // @ts-ignore
    mesh = new THREE.Mesh(geometry, material);
    // @ts-ignore
    mesh.position.x = yCenter;
    // @ts-ignore
    mesh.position.y = zCenter;
    // @ts-ignore
    mesh.position.z = xCenter;
    // @ts-ignore
    mesh.name = blockName;
    // @ts-ignore
    mesh.userData.highlightable = highlightable;
    // @ts-ignore
    mesh.userData.sysid = blockSysid;
    // @ts-ignore
    mesh.userData.type = type;
    // @ts-ignore
    scene.add(mesh);
    // @ts-ignore
    edges = new THREE.EdgesGeometry(geometry);
    // @ts-ignore
    material = new THREE.LineBasicMaterial();
    // @ts-ignore
    material.color.setRGB(lineColor["red"], lineColor["green"], lineColor["blue"]);
    // @ts-ignore
    line = new THREE.LineSegments(edges, material);
    // @ts-ignore
    mesh.add(line);
}
function addThreeJsContent() {
    var cameraPositionX = -4.0;
    var cameraPositionY = 1.9;
    var cameraPositionZ = -4.0;
    var cameraRotationX = 3.141;
    var cameraRotationY = -0.785;
    var cameraRotationZ = 3.141;
    var crosshair;
    var geometry;
    var light;
    var material;
    // @ts-ignore
    velocity = new THREE.Vector3();
    // @ts-ignore
    scene = new THREE.Scene();
    // @ts-ignore
    light = new THREE.AmbientLight(0xffffff);
    scene.add(light);
    // @ts-ignore
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 1000);
    // @ts-ignore
    controls = new THREE.PointerLockControls(camera, document.body);
    controls.getObject().position.set(cameraPositionX, cameraPositionY, cameraPositionZ);
    controls.getObject().rotation.set(cameraRotationX, cameraRotationY, cameraRotationZ);
    scene.add(camera);
    // crosshair
    // @ts-ignore
    geometry = new THREE.Geometry();
    // @ts-ignore
    geometry.vertices.push(new THREE.Vector3(0, 0.001, -0.1));
    // @ts-ignore
    geometry.vertices.push(new THREE.Vector3(0, -0.001, -0.1));
    // @ts-ignore
    geometry.vertices.push(new THREE.Vector3(0.001, 0, -0.1));
    // @ts-ignore
    geometry.vertices.push(new THREE.Vector3(-0.001, 0, -0.1));
    // @ts-ignore
    material = new THREE.LineBasicMaterial({ color: 0x000000 });
    // @ts-ignore
    crosshair = new THREE.LineSegments(geometry, material);
    camera.add(crosshair);
    // @ts-ignore
    renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('my_canvas') });
    renderer.setClearColor(0xf0f3f4);
}
function addEventListeners() {
    document.getElementById('my_canvas').addEventListener('click', pointerLockRequest, false);
    document.addEventListener('keydown', onKeyDown, false);
    document.addEventListener('keyup', onKeyUp, false);
}
/**
 * @function pointerLockRequest
 * @description attempts to lock the mouse pointer when the page is clicked
 */
function pointerLockRequest() {
    var element = document.body;
    // @ts-ignore
    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
    // @ts-ignore
    element.requestPointerLock();
}
/**
 * @function pointerlockchange
 * @description actions to take when the pointer is locked
 */
function pointerlockchange() {
    var element = document.body;
    // @ts-ignore
    if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
        controlsEnabled = true;
        moveForward = false;
        moveBackward = false;
        moveLeft = false;
        moveRight = false;
        moveUp = false;
        moveDown = false;
        prevTime = performance.now();
        document.addEventListener('click', mouseClick, false);
    }
    else {
        document.removeEventListener('click', mouseClick, false);
        controlsEnabled = false;
    }
}
/**
 * @function onKeyDown
 * @description associate actions with key presses
 */
function onKeyDown(event) {
    switch (event.keyCode) {
        case 38: // up
        case 87: // w
            moveForward = true;
            break;
        case 37: // left
        case 65: // a
            moveLeft = true;
            break;
        case 40: // down
        case 83: // s
            moveBackward = true;
            break;
        case 39: // right
        case 68: // d
            moveRight = true;
            break;
        case 16: // left shift
            moveDown = true;
            break;
        case 32: // space
            moveUp = true;
            break;
        case 69: // e
            speedBoost = true;
            break;
        case 80: // p
            //cameraPosRot();
            break;
    }
}
;
/**
 * @function onKeyUp
 * @description  associate actions with key releases
 */
function onKeyUp(event) {
    switch (event.keyCode) {
        case 38: // up
        case 87: // w
            moveForward = false;
            break;
        case 37: // left
        case 65: // a
            moveLeft = false;
            break;
        case 40: // down
        case 83: // s
            moveBackward = false;
            break;
        case 39: // right
        case 68: // d
            moveRight = false;
            break;
        case 16: // left shift
            moveDown = false;
            break;
        case 32: // space
            moveUp = false;
            break;
        case 69: // e
            speedBoost = false;
            break;
    }
}
/**
 * @function rendererResize
 * @description resizes the renderer when the page is resized
 */
function rendererResize() {
    var canvasHeight;
    var canvasWidth;
    var centerHeight;
    var divElement;
    var left;
    var lowerHeight;
    var pagewidth;
    var pageheight;
    var top;
    var topHeight;
    pagewidth = window.innerWidth;
    pageheight = window.innerHeight;
    canvasWidth = pagewidth - 16;
    canvasHeight = pageheight - 16;
    // center divs
    // @ts-ignore
    divElement = document.getElementById("my_canvas");
    divElement.style.position = 'absolute';
    divElement.style.left = "0px";
    divElement.style.top = "0px";
    divElement.style.width = canvasWidth + "px";
    divElement.style.height = canvasHeight + "px";
    // @ts-ignore
    //divElement = document.getElementById("loading");
    if (camera) {
        camera.aspect = canvasWidth / canvasHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(canvasWidth, canvasHeight);
    }
}
//}


</script>
</body>
</html>
